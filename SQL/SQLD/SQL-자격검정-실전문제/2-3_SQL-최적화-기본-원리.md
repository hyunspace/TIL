# 2-3. SQL 최적화 기본 원리

1. 옵티마이저와 실행계획
2. 인덱스 기본
3. 조인 수행 원리 ⭐⭐⭐⭐

<br/>

## 옵티마이저와 실행계획

### 옵티마이저 ⭐

1. CBO (Cost Based Optimizer) *비용기반*
   * 경로를 짰을 때 가장 저렴한, 경제적인 것
   * 소요되는 처리시간 및 CPU, I/O 자원량 등을 계산
     * 인덱스가 있더라도 전체 테이블 스캔이 유리하다고 판단할 수도 있음!
   * 테이블, 인덱스, 컬럼 등 객체의 통계 정보를 사용 👉 통계 정보가 바뀌면 실행계획도 바뀔 수 있음
2. RBO (Rule Based Optimizer) *규칙기반*
   * 규칙에 따라서
   * 가장 우선 순위가 높은 규칙은 Single row by rowid 액세스 기법 (행에 대한 고유 주소 사용)
   * 가장 우선순위가 낮은 것은 전체 테이블 스캔
   * 적절한 인덱스가 존재하면, 항상 인덱스를 사용하려고 함

* 인덱스 범위 스캔은 결과 건수만큼 반환. 결과가 없으면 아무것도 반환 X



### 실행계획 ⭐⭐

> SQL 처리를 위한 실행 절차와 방법을 표현한 것
>
> 조인 방법, 조인 순서, 액세스 기법 등이 표현 됨
>
> 동일 SQL문에 대해 실행 계획이 달라도 결과는 같음

* SQL 처리 흐름도

  * SQL 내부의 실행 계획을 시각화 해서 표현

  * 인덱스 스캔, 테이블 전체 스캔과 같은 액세스 기법 표현
  * 성능 표현도 가능

* 실행 순서

  * 들여 쓰기: 더 많이 들여쓰기 되어 있을수록 일찍 실행

  * 같은 들여쓰기 → 위에 있는 것 먼저 실행

  * 같은 수준이라면 묶어주기

  * 순서가 헷갈린다면 가장 느린 애부터 쓰기




## 인덱스 기본 ⭐

* 개념
  * 기본 인덱스(PK): UNIQUE & NOT NULL 👉 중복 ❌ NULL ❌
  * 보조 인덱스: UNIQUE 인덱스가 아니라면 중복 데이터 가능
  * SELECT 조회 성능을 최적하는 것이 목적
* 특징
  * 자주 변경되는 값은 사용 ❌
  * 테이블의 전체 데이터를 읽는 경우에는 거의 불필요
  * INSERT, UPDATE, DELETE 처리 성능 저하 가능성 O
    * UPDATE에는 부하가 없을 때도 있다!

* 사용하지 않을 때

  * 부정형
  * LIKE
  * 묵시적 형변환

### 종류

* B-TREE
  * 가장 많이 사용되는 인덱스
  * 브랜치 블록(분기를 목적)+리프블록(인덱스 구성하는 컬럼의 값으로 정렬)
  * OLTP 시스템 환경에서 가장 많이 사용
  * 일치 및 범위 검색에 적절
* CLUSTERED 인덱스
  * 인덱스의 리프페이지가 곧 데이터 페이지
  * 리프페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적 정렬 후 저장
  * SQL Server의 클러스터형 인덱스는 오라클의 IOT와 유사
* BITMAP 인덱스
  * SW 및 AD-HOC 질의 환경을 위해 설계
  * 하나의 인덱스 엔트리가 많은 행에 대한 포인터를 저장

## 조인 수행 원리 ⭐⭐⭐⭐

#### Nested Loop Join(NL Join)

* 강점
  * 조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural join)이 효율적일 때 유용
  * 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 **소량 테이블**을 온라인 조회하는 경우에 유용
  * 대용량 소트 작업 시 유용

* 랜덤 액세스
* Driving Table의 조인 데이터 양이 큰 영향을 줌
* 데이터 집계보다는 OLTP의 목록 처리 업무에 많이 사용

#### Sort Merge Join (SMJ)

* 유용
  * 조인 칼럼에 적당한 인덱스가 없어서 NL조인이 비효율적일 때 사용
  * Non-EQUI JOIN 조건에서도 가능

* 조인키를 기준으로 정렬
* 등가/비등자 조인
* DW 등의 데이터 집계 업무에 많이 사용

#### Hash Join

* 강점 
  * 소트 머지 조인하기에 두 테이블이 너무 커서 소트 부하가 심할 때 유용
  * 조인 컬럼에 적당한 인덱스가 없어서 NL이 비효율적일 때
  * 자연 조인 시 드라이빙 집합 쪽으로 조인 액세스 량이 많아 랜덤 액세스 부하가 심할 때
* 행의 수가 작은 테이블을 선행 테이블로 선택하는 것이 유리

* **등가 조인만!**
* 함수 처리 필요
* Hash 처리를 위한 별도 저장공간 필요
* 일반적으로 SMJ보다 우수, but Join 대상 테이블이 Join Key 컬럼으로 정렬 되어 있으면 JML이 더 우수할 수도
* DW 등의 데이터 집계 업무에 많이 사용

|                  NL                   |                  SMJ                   |            Hash            |
| :-----------------------------------: | :------------------------------------: | :------------------------: |
| 적당한 인덱스 O<br />(유니크 인덱스!) | 적당한 인덱스  X<br />조인키 기준 정렬 | 키 속성에 중복값이 적을 때 |
|                                       |             등가O 비등가O              |     only 등가 **EQUI**     |
|    Driving Table 데이터수 영향 큼     |   Driving Table 데이터 수 영향 작음    |   작은 테이블을 선행으로   |
|         OLTP의 목록 처리 업무         |        DW등의 데이터 집계 업무         |  DW등의 데이터 집계 업무   |


