# 1-2. 데이터 모델과 성능

1. 성능 데이터 모델링의 개요
2. 정규화와 성능
3. 반정규화와 성능
4. 대량 데이터에 따른 성능
5. 분산 데이터베이스와 성능

<br/>

## 성능 데이터 모델링의 개요

> 성능을 개선하는 방법

### 성능 데이터 모델링 ⭐

* 아키텍쳐 모델링 👉 구조를 개선한다

  * 테이블, 파티션 등 DB 구조를 수정

* SQL 명령문 👉 빨리하는 방법을 찾는다

  * JOIN 수행 원리 ⭐⭐⭐
  * 옵티마이저
  * 실행 계획

  

## 정규화와 성능

### 정규화 ⭐⭐⭐⭐⭐

* 제 1정규형 `원자성`
  * 모든 속성은 반드시 하나의 값을 가져야 한다
  * **속성 하나에 값 1개**
    * SNS - 트위터, 페이스북, 인스타그램, ... ❌
  * 중복되는 여러 개의 속성 가질 수 없다
    * SNS1- 트위터, SNS2-페이스북, ... ❌
* 제 2정규형 `부분함수 종속성 제거`
  * 엔터티의 일반속성은 주식별자 전체에 종속적이어야 한다.
  
  * 모든 속성은 모든 기본키에 종속이어야 한다!
  
    |      |   주문번호   | 음료코드 | 주문수량 |   음료명   |
    | :--: | :----------: | :------: | :------: | :--------: |
    |  1   | 202303190001 |   1001   |    23    | 아메리카노 |
    |  2   | 202303190002 |   1002   |    42    |  카페라떼  |
    |  3   | 202303190003 |   1004   |    77    | 바닐라라떼 |
  
    * 주문번호+음료코드가 PK인데, 음료는 음료코드에만 종속

* 제 3정규형 `이행함수 종속성 제거`
  * 속성끼리 종속일 수 없다. 기본키에만 종속이어야 한다.
    * 속성 A가 기본키가 아닌 속성 B를 바라보면 안 된다.
* 제 4정규형 `후보키가 상속하는 것 제거`
* 제 5정규형

#### 이상현상

* 삽입 이상
* 수정 이상
* 삭제 이상

### 성능

* SELECT는 느려짐 ← 조인 때문에
* INSERT, UPDATE는 빨리짐 ← 테이블이 작으니까

<br/>

## 반정규화와 성능

> [이미지 출처: 정미나 쌤 강의](https://youtu.be/SS6H2whbfwc)

* 데이터 무결성을 해칠 수 있다 
* 특징
  * 대량 범위
  * 범위 처리
  * 통계 처리 여부
* 다른 방법 먼저 고려
  * 응용 시스템 변경
  * 클러스터링/ 인덱스
  * 뷰

### 테이블 반정규화

* 테이블 병합

  * 1:1 테이블 병합

  * 1:M 관계 테이블 병합

  * 슈퍼 서브 타입 테이블 병합
    * 용량별 처리
      * 작다면 **one to one**
      * 크다면 트랜잭션 유형
    * 트랜잭션 유형 따라 처리
      * 공통점/차이점에 따라 → Plus Type
      * 전체 통합 → Single Type

* 테이블 분할

  * 수직 분할: 열 단위로
  * 수평 분할: 행 단위로

* 테이블 추가

  * 중복 테이블 추가: 타 업무/서버에 있는 테이블과 동일한 구조의 테이블을 추가
  * 통계 테이블 추가: 통계값을 미리 계산해서 저장하는 테이블 추가
  * 이력 테이블 추가: 마스터 테이블에 존재하는 행을 트랜잭션 발생 시점에 따라 복사해두는 테이블 추가
  * **부분 테이블 추가**: 자주 조회되는 컬럼만 모아서 따로 테이블 추가

### 컬럼 반정규화

* 중복 컬럼 추가

  * 조인 프로세스를 줄이기 위해서
  * SELECT 비용은 감소, UPDATE 비용은 증가

  ![스크린샷 2023-03-19 오전 12.13.56](assets/스크린샷 2023-03-19 오전 12.13.56.png)

* 파생 컬럼 추가
  * 계산을 통해 얻어지는 결과값을 테이블에 컬럼으로 저장
* 이력 테이블 컬럼 추가
  * 이력 테이블에 기능성 컬럼 추가 (최신 여부, 시작일/종료일 등)

### 관계 반정규화

* 중복 관계 추가

  * 데이터 처리를 위해 여러 경로를 거쳐야 할 경우 관계를 중복 시킴

    ![스크린샷 2023-03-19 오전 12.16.06](assets/스크린샷 2023-03-19 오전 12.16.06.png)

<br/>

## 대량 데이터에 따른 성능 ⭐

* ROW MIGRATION
  * 저장 공간 부족 + 이미 있던 데이터를 업데이트할 때
  * 업데이트로 인해 늘어난 부분을 저장할 공간이 없어서 다른 곳으로 옮겨서*migration* 저장
* ROW CHAINING
  * 저장 공간 부족 + 새로운 데이터를 입력하려고 할 때
  * 하나의 행을 하나의 블록에 저장할 수 없어서 여러 블록에 연결*chaining*하듯 저장
* 파티셔닝: 위의 문제를 해결하기 위한 방안
  * List Partitioning
  * Range Partitioning
    * 가장 많이 쓰임
    * 관리하기 쉬움
  * Hash Partitioning

<br/>

## 분산 데이터베이스와 성능

* 데이터 무결성을 해칠 수 있다 (반정규화와 비슷)
* 목표
  * 위치 투명성
  * 중복 투명성
  * 병행 투명성
  * 장애 투명성

 

