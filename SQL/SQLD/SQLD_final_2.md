# SQLD 총정리 2

> 참고 강의 [SQLD 최조 정리강의 2편](https://www.youtube.com/watch?v=PjCSvexo3Ow)
>
> 추가 참고 자료 [티스토리](https://stealswan.tistory.com/184)



## 윈도우 함수

> 문제 많이 풀어보기

* **ROWS** vs. **RANGE** 차이점
* **RANK** vs. **DENSE RANK**
  * RANK: 중복을 건너 뛴다.
  * DENSE RANK: 중복을 건너 뛰지 않는다
* **PARTITION BY**
* **ORDER BY**



## 계층형 질의 ⭐

* prior 자식 데이터 = 부모 데이터 `프자부`
* 부모 데이터에서 자식 데이터로 가는 경우 => 순방향 `부자순`

> 4분 초반 예제 설명 다시 보기



## 절차형 PL/SQL

* EXCEPTION 예외 처리 부분 => **생략 가능**
* **PROCEDURE** vs. **TRIGGER** vs. **USER DEFINED FUNCTION**



## 데이터 모델링



## ENTITY✔

* 업무 상 관리하고자 하는 대상
* 특징
* 분류
  * 유형/개념/사건
  * 기본/중심/행위



## 속성✔

* 관리하고자 하는 대상인 인스턴스의 특성

* 분류
  * 기술
  * 설명
  * 파생



## 도메인 ⭐

* 값의 범위. 어떤 값을 가져야 하는가!
* 데이터 유형, 크기, 제약 조건
* 물리적 데이터 모델링 => check, pk, ...



## 관계

### IE 모델링

![What Are the Different Types of Data Models? | Vertabelo Database Modeler](assets/4.png)

[이미지 출처](https://vertabelo.com/blog/types-data-models/)

* 필수 관계는 | , 선택은 O
* 식별(실선)/ 비식별자(점선) 관계(ERD)

#### Barker

![Richard Barker s Notation (as Used by Oracle Corporation) | Requirements  Analysis: From Business Views to Architecture](assets/bfig04.gif)

[이미지 출처](https://flylib.com/books/en/1.172.1.92/1/)

* 필수 관계 실선, 선택 관계는 점선
* UID(Unique Identifier) Bar 사용하여 표기



## 식별자✔

* 주식별자의 특징 `유최불존`
  * 유일성
  * 최소성
  * 불변성
  * 존재성: NOT NULL

* 모두 만족하면 후보키, 그 중 하나가 기본키(PK)/ 대체키



## 식별자 관계, 비식별자 관계✔

|                     식별자 관계                      |                   비식별자 관계                    |
| :--------------------------------------------------: | :------------------------------------------------: |
|                         강함                         |                        약함                        |
| SQL 구문이 복잡<br />(pk 상속으로 인한 속성 수 증가) | 불필요한 JOIN 발생 => 느려짐<br />(pk가 일반 속성) |
|                         실선                         |                        점선                        |

#### ERD 서술 규칙

* 왼쪽 위 → 오른쪽 아래로
* 관계명 반드시 표기하지 않아도 됨
* UML → 객체 지향 모델링에서만 쓰임



## 성능 데이터 모델링

* 성능을 개선하는 방법

#### 1. 아키텍쳐 모델링

> 구조를 개선한다

* 테이블, 파티션 등 DB 구조를 수정



#### 2. SQL 명령문

> 빨리 하는 방법을 찾는다

* JOIN 수행 원리 ⭐⭐⭐
* optimizer
* 실행 계획



## 정규화 ⭐⭐⭐⭐⭐

#### 방법

* 1차
  * 원자성
* 2차 ⭐
  * 부분함수 종속성 제거
* 3차 ⭐
  * 이행함수 종속성 제거
* 4차
  * 후보키가 상속하는 것 제거

#### 이상현상

* 삭제 이상
* 삽입 이상

#### 성능

* SELECT는 느려짐 ← 조인 때문에
* INSERT, UPDATE는 빨리짐 ← 테이블이 작으니까





## 반정규화

* 데이터 무결성을 해칠 수 있다 ⭐
* 특징
  * 대량 범위
  * 범위 처리
  * 통계 처리 여부
* 다른 방법 먼저 고려
  * 응용 시스템 변경
  * 클러스터링/ 인덱스
  * 뷰

* 반정규화 방법

  1. 테이블 반정규화

     * 병합
       * 1:1 & 1:M : 슈퍼/서브

     * 분할
       * 부분 테이블
       * 통계 테이블
       * 중복 테이블

  2. 속성 반정규화
     * 파생
     * 오류
     * 이력 컬럼 추가
     * PK → 일반 속성으로 편입
     * 중복 속성
  3. 관계 반정규화
     * 중복 관계 추가





## 대량 데이터에 따른 성능

* ROW MIGRATION, ROW CHAINING 개념 읽어보기
* 파티셔닝: 위의 문제를 해결하기 위한 방안
  * List Partitioning
  * Range Partitioning
    * 가장 많이 쓰임
    * 관리하기 쉬움
  * Hash Partitioning



## 슈퍼/서브 타입

1. 용량 별 처리
   * 작다면 → **one to one**
   * 크다면 → 트랜잭션 유형 
2. 트랜잭션 유형에 따라 처리
   * 공통점/차이점에 따라 → Plus Type
   * 전체 통합 → Single Type



## 분산 데이터베이스

* 데이터 무결성을 해칠 수 있다 (반정규화와 비슷)
* 목표
  * 위치 투명성
  * 중복 투명성
  * 병행 투명성
  * 장애 투명성



## 조인 수행 원리 ⭐⭐⭐⭐

> 문제 많이 풀기! 4문제 나온다
> SQL 자격검정(노랭이) 선택지만 외우고 가자

#### NL

* 랜덤 액세스
* 대용량 솔트 작업시 유리

#### Sort merge

* 조인키를 기준으로 정렬
* 등가/비등자 조인

#### Hash

* 등가 조인만!
* 함수 처리 필요
* 선행 테이블이 작다
* Hash 처리를 위한 별도 저장공간 필요



## Optimizer 옵티마이저

1. CBO (Cost Based Optimizer)
   * 경로를 짰을 때 가장 저렴한, 경제적인 것
2. RBO (Rule Based Optimizer)
   * 규칙에 따라서



## 인덱스

> 언제 사용되는가? 예외 기억하기!

* 사용하지 않을 때

  * 부정형
  * LIKE
  *  묵시적 형변환

* 인덱스 사용시 성능 감소 (느려지는 경우)

  ∵ 이미 목차를 만들어 놨는데(번호를 매겨놨는데), 내용이 바뀌면 순서에 영향을 주므로!

  * INSERT
  * UPDATE
  * DELETE



## 실행 계획(순서) ⭐

* 들여 쓰기: 더 많이 들여쓰기 되어 있을수록 일찍 실행
* 같은 들여쓰기 → 위에 있는 것 먼저 실행
* 같은 수준이라면 묶어주기
* 순서가 헷갈린다면 가장 느린 애부터 쓰기



## Pivot / Unpivot

> 빈칸이 나오면 둘 중에 골라서 정하는 것





## Merge

